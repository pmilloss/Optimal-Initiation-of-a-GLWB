simulate_XM <- function(nsim, X0 = 1, M0 = X0, dS_S, N, d = 1, psi, phi, beta)
{
  # calculate simulated values of X and M given simulated returns dS_S
  
  # nsim: number of simulations, a scalar
  # X0: initial value of the personal account, a scalar
  # M0: initial value of the base account, a scalar
  # dS_S: a (N x nsim) - matrix with the simulated log returns of the reference fund 
  # N: the number of periods, a scalar (integer)
  # d: the time step (a fraction of year)
  # psi: the management fee
  # phi: the insurance fee
  # beta: the roll-up rate
  
  X <- M <- matrix(0, nrow = N + 1, ncol = nsim)
  rownames(X) <- rownames(M) <- seq(0, N)
  # set up matrices for X and M
  
  X[1, ] <- X0
  M[1, ] <- M0
  # initialize first row (time 0)
  
  for(j in 1 : N)
  {
    # given X[j, ], M[j, ] (time j - 1) calculate X[j + 1, ], M[j + 1] (time j)
    
    X[j + 1, ] <- pmax(X[j, ] * (1 + dS_S[j, ] - psi * d) - phi * d * M[j, ], 0)
    M[j + 1, ] <- pmax(M[j, ] * (1 + beta * d), X[j + 1, ])
  }
  
  return(list(X, M))
  # list of matrices
}

# simulate_XMt <- function(nsim, t, Xt, Mt, dS_S, N, d, psi, phi, beta, gt, tau, B)
# {
#   # at time t < N, calculate simulated values of X^t_u and M^t_u (fictitious evolution of personal and account values if GLWB is initiated at t) for u>=t, given initial values Xt, Mt and simulated returns dS_S. Use this values to calculate Ft, present value at t of all future cash-flows generated by a contract that has been initiated at t.
#   
#   # nsim: number of simulations, a scalar
#   # t: current time at which GLWB is initiated, an integer
#   # Xt: initial value of the personal account at t, a vector of size nsim
#   # Mt: initial value of the personal account, a vector of size nsim
#   # dS_S: a (N x nsim) - matrix with the simulated log returns of the reference fund 
#   # N: the number of periods, a scalar (integer)
#   # d: the time step (a fraction of year)
#   # psi: the management fee ()
#   # phi: the insurance fee
#   # beta: the roll-up rate
#   # gt: the annuity rate if GLWB is initiated at t, a scalar
#   # tau: a vector of time of deaths, integers
#   # B: : a (N x nsim) - matrix with the simulated (or calculated) discount factors
#   
#   Ft <- rep(0, times = nsim)
#   # set up vector for Ft
#   
#   Xt0 <- Xt
#   Mt0 <- Mt
#   # starting values for X^t and M^t
#   
#   # for(j in 1 : (N - t))
#   for(j in (t + 1) : N)
#       {
#     # calculates new values for X^t and M^t from old ones, update iteratively Ft then assign new value to X^t, M^t
#     # j = current period
#     
#     # XMt1 <- XMt1.0(Xt0, Mt0, dS_S[j - 1, ], d, psi, phi, beta = 0, gt)# CHECK t + j IS CORRECT?????
#     XMt1 <- XMt1.0(Xt0, Mt0, dS_S[j, ], d, psi, phi, beta = 0, gt)
#     
#     # Ft <- Ft + (gt * Mt0 * (tau >= t + j) + XMt1[, 1] * (tau == t + j)) * (B[t + 1] / B[t + j + 1, ])
#     Ft <- Ft + (gt * Mt0 * (tau >= j) + XMt1[, 1] * (tau == j)) * (B[t + 1] / B[j + 1, ])
#     
#   Xt0 <- XMt1[, 1]
#   Mt0 <- XMt1[, 2]
#           
#   }
#   
#   return(Ft)
# }

calculate_F <- function(nsim, Xt, Mt, dS_S, N, d = 1, psi, phi, beta = 0, gt, tau, B)
{
  # for all time 0 <= t < N, calculate simulated values of X^t_u and M^t_u (fictitious evolution of personal and account values if GLWB is initiated at t) for u>=t, given initial values Xt, Mt and simulated returns dS_S. Use this values to calculate Ft, present value at t of all future cash-flows generated by a contract that has been initiated at t.
  
  # nsim: number of simulations, a scalar
  # Xt: simulated values of the personal account, an (N x nsim) matrix
  # Mt: simulated values of the personal account, , an (N x nsim) matrix
  # dS_S: an (N x nsim) - matrix with the simulated log returns of the reference fund 
  # N: the number of periods, a scalar (integer)
  # d: the time step (a fraction of year)
  # psi: the management fee
  # phi: the insurance fee
  # beta: the roll-up rate (= 0 in this case)
  # gt: the annuity rate if GLWB is initiated at t, a scalar
  # tau: a vector of time of deaths (integers) of length nsim
  # B: : an (N x nsim) - matrix with the simulated (or calculated) discount factors
  
  F0N <- matrix(0, nrow = N, ncol = nsim)
  rownames(F0N) <- 0 : (N - 1)
  
  for(t in 0 : (N - 1))
  {
    Ft <- rep(0, times = nsim)
    # set up vector for Ft
    
    Xt0 <- Xt[t + 1, ]
    Mt0 <- Mt[t + 1, ]
    # starting values for X^t and M^t
    
    for(j in (t + 1) : N)
    {
      # calculates new values for X^t and M^t from old ones, update iteratively Ft then assign new value to X^t, M^t
      # j = current period
      
      Xt1 <- pmax(Xt0 * (1 + dS_S[j, ] - psi * d) - (phi + gt) * d * Mt0, 0)
      Mt1 <- pmax(Mt0 * (1 + beta * d), Xt1)
      
      Ft <- Ft + (gt * d * Mt0 * (tau >= j) + Xt1 * (tau == j)) * (B[t + 1, ] / B[j + 1, ])
      
      Xt0 <- Xt1
      Mt0 <- Mt1
    }
    
    F0N[t + 1, ] <- Ft

      }
  
  return(F0N)
}


# DA VERIFICARE
# calculate_G <- function(nsim, Xt, Mt, state_variables, dS_S, N, d, psi, phi, beta = 0, gt, tau, B)
# {
#   # for all time 0 <= t < N, calculate simulated values of X^t_u and M^t_u (fictitious evolution of personal and account values if GLWB is initiated at t) for u>=t, given initial values Xt, Mt and simulated returns dS_S. Use this values to calculate Ft, present value at t of all future cash-flows generated by a contract that has been initiated at t.
#   
#   # nsim: number of simulations, a scalar
#   # Xt: simulated values of the personal account, an (N x nsim) matrix
#   # Mt: simulated values of the personal account, , an (N x nsim) matrix
#   # dS_S: an (N x nsim) - matrix with the simulated log returns of the reference fund 
#   # N: the number of periods, a scalar (integer)
#   # d: the time step (a fraction of year)
#   # psi: the management fee
#   # phi: the insurance fee
#   # beta: the roll-up rate (= 0 in this case)
#   # gt: the annuity rate if GLWB is initiated at t, a scalar
#   # tau: a vector of time of deaths (integers) of length nsim
#   # B: : an (N x nsim) - matrix with the simulated (or calculated) discount factors
#   
#   G0N <- matrix(0, nrow = N, ncol = nsim)
#   rownames(G0N) <- 0 : (N - 1)
#   
#   for(t in 0 : (N - 1))
#   {
#     Ft <- rep(0, times = nsim)
#     # set up vector for Ft
#     
#     Xt0 <- Xt[t + 1, ]
#     Mt0 <- Mt[t + 1, ]
#     # starting values for X^t and M^t
#     
#     for(j in (t + 1) : N)
#     {
#       # calculates new values for X^t and M^t from old ones, update iteratively Ft then assign new value to X^t, M^t
#       # j = current period
#       
#       Xt1 <- pmax(Xt0 * (1 + dS_S[j, ] - psi * d) - (phi + gt) * d * Mt0, 0)
#       Mt1 <- pmax(Mt0 * (1 + beta * d), Xt1)
#       
#       Ft <- Ft + (gt * d * Mt0 * (tau >= j) + Xt1 * (tau == j)) * (B[t + 1, ] / B[j + 1, ])
#       
#       Xt0 <- Xt1
#       Mt0 <- Mt1
#     }
#     
#     F0N[t + 1, ] <- Ft
#     
#   }
#   
#   return(F0N)
# }




# X0 <- 1
# M0 <- X0
# 
# r <- 0.03
# sigma <- 0.20
# 
# psi <- 0.075
# phi <- 0.03
# 
# g <- 0.05
# 
# beta <- 0.05
# 
# nsim <- 10000
# N <- 60
# d <- 1
# 
# 
# set.seed(1)
# dS_S <- simula_dS_S_GBM(nsim, N, r, sigma, d)
# 
# 
# XM <- simulate_XM(nsim, X0 = 1, M0 = X0, dS_S = dS_S, N = N, d = d, psi = psi, phi = phi, beta = beta)
# 
# 
# setwd("C://Dropbox//Università//Lavori//Monte Carlo valuation of the initiation option in a GLWB variable annuity")
# 
# pdf("personalandbaseaccount.pdf")
# 
# plot(XM[[1]][,100], type = "b", main = "personal account and base amount", xlab = "time", ylab = "", pch = 20, ylim = c(0, max(XM[[2]][,100])))
# lines(XM[[2]][,100], col = "red")
# legend <- c("personal", "base")
# legend(x = "topleft", legend = legend, col = c("black", "red"), lty = 1, bty = "n")
# 
# dev.off()