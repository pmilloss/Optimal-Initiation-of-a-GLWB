# for all time 0 <= t < N, calculate simulated values of X^t_u and M^t_u (fictitious evolution of personal and account values if GLWB is initiated at t) for u>=t, given initial values Xt, Mt and simulated returns dS_S. Use this values to calculate Gt, present value at t of all future cash-flows generated by a contract that has been initiated at t and surrendered optimally.

# nsim: number of simulations, a scalar
# Xt: simulated values of the personal account, an (N x nsim) matrix
# Mt: simulated values of the personal account, , an (N x nsim) matrix
# dS_S: an (N x nsim) - matrix with the simulated log returns of the reference fund 
# N: the number of periods, a scalar (integer)
# d: the time step (a fraction of year)
# psi: the management fee
# phi: the insurance fee
# beta: the roll-up rate (= 0 in this case)
# gt: the annuity rate if GLWB is initiated at t, a scalar
# tau: a vector of time of deaths (integers) of length nsim
# B: : an (N x nsim) - matrix with the simulated (or calculated) discount factors

calculate_G <- function(nsim, X, M, state_var, dS_S, Nbar, psi, phi, beta = 0, gt, tau, B, penalty, basis_fun)
{
  GG <- matrix(0, nrow = Nbar, ncol = nsim)

  for(t in 0 : (Nbar - 1))
  {
    ind_surv_t <- which(tau > t)
    tau_t <- tau[ind_surv_t]
    nsim_t <- length(ind_surv_t)
    
    # contract initiated at t
    Xt <- Mt <- matrix(0, nrow = Nbar - t + 1, ncol = nsim_t)
    
    Xt[1, ] <- X[t + 1, ind_surv_t]
    Mt[1, ] <- M[t + 1, ind_surv_t]
    
    for(v in 1 : (Nbar - t))
    {
      Xt[v + 1, ] <- pmax(Xt[v, ] * (1 + dS_S[v, ind_surv_t] - psi) - (phi + gt) * Mt[v, ], 0)
      Mt[v + 1, ] <- pmax(Mt[v, ] * (1 + beta), Xt[v, ])
    }
    
    G_temp <- (gt * Mt[cbind(tau_t - t, 1 : nsim_t)] + Xt[cbind(tau_t - t + 1, 1 : nsim_t)]) * B[cbind(tau_t, ind_surv_t)] / B[cbind(tau_t + 1, ind_surv_t)]

    pai_bar <- tau_t
    
    if(t < (Nbar - 1))
    {
      for(v in (Nbar - 1) : (t + 1))
      {
        
        # vector of indices in 1 : nsim_u of survivors in v
        ind_surv_v <- which(tau_t > v)
        
        # regression_matrix[j, ] <- basis_functions(c(X[n + 1, ind_surv_j], M[n + 1, ind_surv_j])) # AGGIUNGERE ALTRE VARIABILI DI STATO
        if(is.null(state_var)) Z <- cbind(1, Xt[v - t + 1, ind_surv_v], M[v - t + 1, ind_surv_v]) else Z <- cbind(1, X[v - t + 1, ind_surv_v], M[v - t + 1, ind_surv_v], sapply(state_var, extract_row_col, row = v - t + 1, col = ind_surv_v))
        # Z <- cbind(Xt[v - t + 1, ind_surv_v], Mt[v - t + 1, ind_surv_v])
        # matrix of state variables
        
        reg_mat <- t(apply(Z, 1, basis_fun))
        # apply "basis_functions" to each row of Z to build the regression matrix
        
        # LSMC to calculate the continuation value
        cont_value_LSMC <- lm.fit(reg_mat, G_temp[ind_surv_v])$fitted.values
        
        surr_value <- Xt[v - t + 1, ind_surv_v] * (1 - penalty)
        
        index_surr <- (surr_value > cont_value_LSMC)
        
        pai_bar[ind_surv_v][index_surr] <- v
        
        G_temp[ind_surv_v] <- (gt * Mt[v - t, ind_surv_v] + G_temp[ind_surv_v] * (pai_bar[ind_surv_v] > v) + Xt[v - t + 1, ind_surv_v] * (1 - penalty) * (pai_bar[ind_surv_v] == v)) * B[v, ind_surv_v] / B[v + 1, ind_surv_v]
      }
    }
  GG[t + 1, ind_surv_t] <- G_temp
  }
  return(GG)
}